\chapter{\gls{loco} Algorithm}

\gls{loco}, a shortening for Linear Optics from Closed Orbits, is an algorithm which the main objective is to calibrate the accelerator model in order to reproduce the measured orbit response matrix in the real machine. Once this correspondence is achieved, it is considered that the calibrated model is a representation of the real machine in terms of magnetic lattice. Therefore, one can access the information from the real accelerator by analysing the model. The principal information that is studied in this process is related to linear optics functions, betatron and dispersion, allowing for its disturbances detection and, more importantly, to determine its corrections, pushing the measured parameters to the nominal ones.

This method has been applied to several synchrotron light sources over the years and has been proven to be efficient both to detect optics perturbations and to correct the machine linear optics. Besides that, with the realization of 4\ts{th} generation light sources, which uses innovative and very compact magnetic lattices and optics, some details and subtleties of LOCO should be revisited to successfully apply the algorithm in modern machines such as Sirius storage ring. This chapter is dedicated to present the LOCO algorithm and to discuss the aforementioned details.

\section{Orbit Response Matrix Analysis}

If a $j$-th dipolar corrector strength is locally varied by the amount $\Delta \theta_j$, the electron closed orbit will be distorted. The horizontal and vertical distortions ($\Delta x$ and $\Delta y$) can be measured by the \gls{bpm}s. With the distortions measured by the $i$-th \gls{bpm}, the following quantities can be calculated in this process:

\begin{align}
    M^{uv}_{ij} &= \dfrac{\Delta u_i}{\Delta \theta_j^v}
\end{align}

If the corrector magnet is horizontal, $v=x$ and if it is vertical, $v=y$. For each corrector varied, one can measure the corresponding positions variations given by every \gls{bpm}, horizontally $u=x$ and vertically $u=y$. Then this values can be cast in an array $\mathbf{M}$, called \gls{orm}. The general organization of the elements in this matrix is the following:

\begin{equation}
    \mathbf{M} = \begin{bmatrix}
    \mathbf{M}^{xx} & \mathbf{M}^{xy} \\
    \mathbf{M}^{yx} & \mathbf{M}^{yy} 
\end{bmatrix}
\end{equation}

The sub-matrices $\mathbf{M}^{xx}$ and $\mathbf{M}^{yy}$ in the on-diagonal blocks are the principal elements in the \gls{orm}. In a magnetic lattice with zero transverse coupling (such as the nominal magnetic lattice for Sirius storage ring) the sub-matrices $\mathbf{M}^{xy}$ and $\mathbf{M}^{yx}$ in the off-diagonal blocks are zero as well. The order of magnitude of the elements in off-diagonal blocks compared to the on-diagonal blocks is smaller by the same order of magnitude of the transverse coupling, typically a few percent without corrections.

It is possible to obtain an analytical expression for the \gls{orm} elements in the on-diagonal blocks. In the equation \eqref{eq:orbit_distortion} the orbit distortion in the presence of a given dipolar kick distribution $\theta_u(s)$ is given. For the special case where the kick distribution is discrete, localized in the dipolar correctors positions $s_j$, with values $\Delta \theta^{u}_{j}$, the equation is rewritten in the form:

\begin{equation}
    \Delta u(s_i) = \sum_{j} \dfrac{\sqrt{\beta_{u}(s_i)\beta_{u_j}(s_j)}}{2\sin\left(\pi\nu_{u}\right)} \Delta \theta^{u}_j \cos\left( |\varphi_{u}(s_i) - \varphi_{u}(s_j)| - \pi\nu_{u} \right).
    \label{eq:discrete_orbit_distortion}
\end{equation}

The orbit distortions $\Delta u(s_i)$ are also measured in localized positions $s_i$, where the \gls{bpm}s are installed. The equation above can be cast in the form $\Delta u_i = \sum_{j} M_{ij}^{uu} \Delta \theta_{j}^{u}$, therefore the \gls{orm} elements can be recognized as:

\begin{align}
M_{ij}^{uu} = \dfrac{\sqrt{\beta_{u}(s_i)\beta_{u}(s_j)}}{2\sin\left(\pi\nu_{u}\right)}\cos\left( |\varphi_{u}(s_i) - \varphi_{u}(s_j)| - \pi\nu_{u} \right).
\label{eq:matrix_elements}
\end{align}

Note that the \gls{orm} elements contains information about the local betatron function in the \gls{bpm}s and correctors positions. It also encodes the relative betatron phase advance between these two devices and depends on the betatron tune, a global parameter. 

Following the organization used in the \gls{orm}, the orbit distortions and the dipolar kick variations can be arranged in vectors

\begin{align*}
    \Delta \vec{u} &= \left(\Delta x_1, \ldots, \Delta x_{\mathrm{N}_{\mathrm{BPM}}}, \Delta y_1, \ldots, \Delta y_{\mathrm{N}_{\mathrm{BPM}}}\right), \\
    \Delta \vec{\theta} &= \left(\Delta \theta_1^x, \ldots, \Delta \theta_{\mathrm{N}_{\mathrm{CH}}}^x, \Delta \theta_1^y, \ldots, \Delta \theta_{\mathrm{N}_{\mathrm{CV}}}^y\right).
\end{align*}

$\mathrm{N}_{\mathrm{BPM}}$ are the number of \gls{bpm}s, $\mathrm{N}_{\mathrm{CH}}$ are the number of horizontal correctors (CH) and $\mathrm{N}_{\mathrm{CV}}$ the number of vertical correctors (CV). The orbit correction budget for Sirius storage ring has $\mathrm{N}_{\mathrm{BPM}} = 160$, $\mathrm{N}_{\mathrm{CH}} = 120$ and $\mathrm{N}_{\mathrm{CV}} = 160$. 

In this vectorial form, the equation \eqref{eq:discrete_orbit_distortion} is $\Delta \vec{u} = \mathbf{M} \Delta \vec{\theta}$, so the \gls{orm} has dimension $2 \mathrm{N}_{\mathrm{BPM}} \times \left(\mathrm{N}_{\mathrm{CH}} + \mathrm{N}_{\mathrm{CV}}\right)$. 

Suppose that the \gls{bpm}s measures the orbit distortion $\vec{u}_{\mathrm{d}}$. With the dipolar correctors it is possible to produce a orbit variation that cancels the measured orbit distortion. From $\vec{u}_{\mathrm{d}} + \Delta \vec{u} = 0$, we can calculate that the required kicks variations are $\Delta \vec{\theta} = -\mathbf{M}^{-1}\vec{u}_{\mathrm{d}}$. Since the actual problem is non-linear, the corrections must be calculated and applied iteratively until convergence. Generally, $2\mathrm{N}_{\mathrm{BPM}} \neq \mathrm{N}_{\mathrm{CH}} + \mathrm{N}_{\mathrm{CV}}$, then the \gls{orm} is a rectangular matrix and $\mathbf{M}^{-1}$ is not an ordinary inverse. In this case, a pseudo-inverse \gls{orm} may be obtained with the method of \gls{svd} pseudo-inversion which is described in Appendix~\ref{appendix:svd}. Fundamentally this is a minimization of squares method and, depending on the number of knobs (correctors) compared to the number of data points (BPMs), it also minimizes the knobs variations required to minimize the figure of merit, in this case, the orbit distortion.

It is common to also include the \gls{rf} frequency as a knob in the orbit correction budget. It can be done by adding the orbit distortion vector produced after a variation in the RF frequency in the last column of the \gls{orm}. From \eqref{eq:delta_freq} and using $\Delta u_i = \eta_u(s_i) \delta$, we obtain:

\begin{equation}
    \dfrac{\Delta u_i}{ \Delta f_{\mathrm{rf}}} = - \dfrac{\eta_u(s_i)}{\alpha f_{\mathrm{rf}}}.
\end{equation}

In this way, the correction calculations for the orbit distortions also provides the variation of the \gls{rf} frequency (this is useful, for example, to correct thermal variations in the storage ring tunnel). It is important to observe that the \gls{rf} signature in the orbit distortion is very different from the signature created by the correctors, since the first depends on the dispersion function and the latter on the betatron function.

The \gls{orm} with the RF frequency column is then a matrix with dimension $2 \mathrm{N}_{\mathrm{BPM}} \times \left(\mathrm{N}_{\mathrm{CH}} + \mathrm{N}_{\mathrm{CV}}+1\right)$. For the Sirius storage ring, the \gls{orm} is a $320 \times 281$ matrix. Beyond the practical function of calculating the corrections for orbit distortions, the \gls{orm} contains a lot of information about the linear optics (betatron function, phase advance and horizontal dispersion function) and rotation errors (elements of off-diagonal blocks related to betatron coupling and the vertical dispersion function). The \gls{loco} algorithm explores precisely the information contained in the \gls{orm}.



% \begin{align}
%     u_i\left({\theta_j^u+\Delta\theta_j^u}\right) = u_i\left(\theta_j^u\right) + \dfrac{\partial u_i}{\partial \theta_j^u} \Delta \theta_j^u
% \end{align}

% \begin{equation}
%     M^{u u}_{ij} = \dfrac{\Delta u_i (+\Delta \theta_j^u/2) - \Delta u_i (-\Delta \theta_j^u/2)}{\Delta \theta_j^u}.
%     \label{medida}
% \end{equation}

% $M_{ij} = \dfrac{\partial u_i}{\partial \theta_j^u} + O(3)$.

\section{Minimization problem}

To implement the LOCO algorithm, a computational model of the storage ring is required. In this model, it is possible to calculate the nominal \gls{orm}. That can be done by simulating the measurement process which consists in varying the correctors strength and getting the corresponding orbit in all BPMs, for every corrector in the lattice. The nominal \gls{orm} calculation can be perfomed also using the transfer matrices of the lattice. In this formalism, which is much faster computationally, the \gls{orm} elements can be obtained by the composition of the transfer matrices of the elements between the correctors and the \gls{bpm}s. If non-linear effects in the orbit distortion can be disregarded, the two calculation methods produces very similar \gls{orm}s, thus, for the sake of sparing computation time, the transfer matrices approach is often used.

The LOCO algorithm can be viewed as a model dependent minimization problem. The main goal is to find a set of parameters in the computational model that best reproduce the measured \gls{orm}. Equivalently, it seeks for the global minimum of the square difference:

\begin{equation}
    \chi^2 = \sum_{i, j} \left(M^{\mathrm{measured}}_{ij} - M^{\mathrm{model}}_{ij}\right)^2 := \sum_{{k = (i,j)}} V_{k}^2.
    \label{eq:chi2}
\end{equation}

The vector $\vec{V}$ has $2 \times \mathrm{N}_{\mathrm{BPM}} \times \left(\mathrm{N}_{\mathrm{CH}} + \mathrm{N}_{\mathrm{CV}}+1\right)$ elements and it is obtained by the vectorization transformation applied in the difference of \gls{orm}s. For example, the vectorization of a $2 \times 2$ matrix is:

\begin{equation}
        \mathbf{A} = \begin{bmatrix}
     a_{11} & a_{12} \\
     a_{21} & a_{22} 
\end{bmatrix} \Rightarrow \mathrm{vec}\left(\mathbf{A}\right) = \begin{bmatrix}
     a_{11}  \\
     a_{12} \\
     a_{21} \\ 
     a_{22} 
\end{bmatrix}.
\end{equation}

Let the dimension of $\vec{V}$ be denoted by $\mathrm{N}_{\mathrm{data}}$. For the Sirius storage ring, $\mathrm{N}_{\mathrm{data}} = 2 \times 160 \times 281 = 89920$.

The minimization is performed by changing some parameters in the computational model, so the model \gls{orm} $\mathbf{M}^{\mathrm{model}}$ is also changed and the square difference $\chi^2$, i.e., the modulus of the vector $\vec{V}$, might be reduced. It is used two methods to calculate the parameters variation that minimizes $\chi^2$: \gls{gn} and \gls{lm}.

\subsection{Gauss-Newton Algorithm}

Suppose that each element $V_k$ of the vector is a function of several parameters $\vec{P} = \left(P_1, \ldots, P_{\mathrm{N}_{\mathrm{knobs}}}\right)$. The number of knobs used as parameters are represented by $\mathrm{N}_{\mathrm{knobs}}$. Then it is possible to calculate the linear response of the vector elements for a given change in the parameters:

\begin{equation}
\Delta V_{k} = \sum_{l}\dfrac{\partial V_{k}}{\partial P_{l}} \Delta P_{l}.
\label{eq:loco_params}
\end{equation}

The above equation can be cast in a vectorial form as well, with $\Delta \vec{V} = \mathbf{J}\Delta \vec{P}$, where the matrix $\mathbf{J}$ is called LOCO jacobian and its elements are 

\begin{equation}
    J_{kl} = \dfrac{\partial V_{k}}{\partial P_{l}}.
\end{equation}

The \gls{orm} can be interpreted as a jacobian as well, if the orbit distortions are viewed as a function of the dipolar kicks. So, if $u_i = u_i\left(\theta_1, \ldots, \theta_{\mathrm{N}_{\mathbf{corrs}}}\right)$, the \gls{orm} elements are $M_{ij} = \dfrac{\partial u_i}{\partial \theta_j}$. The LOCO jacobian is the derivative of the \gls{orm} relative to the parameters $\vec{P}$, thus it is actually the second order derivative of the orbit distortion relative to the dipolar kicks and the parameters, which can be written as a rank-3 tensor with elements given by:

\begin{equation}
    J_{ijl} = \dfrac{\partial^2 u_i}{\partial P_{l}\partial \theta_j}.
\end{equation}

The vectorization uses the indices $(i, j)$ of this rank-3 tensor to convert them in one index $k = i \otimes j$ and build a rank-2 tensor $J_{kl}$, which is the LOCO jacobian matrix.

Depending on the parameter type, it is possible to calculate the LOCO jacobian matrix analytically or numerically, by changing the parameter and calculating the correspondent change in the vector $\vec{V}$. The numerical jacobian calculation typically dominates the running time for the LOCO algorithm.

The \gls{gn} algorithm was already presented in the calculation of kicks to correct the orbit distortion. This algorithm is generally used to solve non-linear least squares problems. 

Suppose that a \gls{orm} was measured in the real storage ring and the initial model \gls{orm} is calculated with the initial parameters $\vec{P}_0$, so the initial difference vector is obtained $\vec{V}_0$. The goal is to apply variations in the difference vector such that $\vec{V}_0 + \Delta \vec{V} = 0$. From $\Delta \vec{V} = \mathbf{J}\Delta \vec{P}$, we obtain that $\Delta \vec{P}_0 = -\mathbf{J}^{-1} \vec{V}_0$, so changing the parameters by $\vec{P}_1 = \vec{P}_0 + \Delta \vec{P}_0$ will reduce the modulus of the new square difference vector $\vec{V}_1$. Since the problem is non-linear, proceeding in that manner iteratively, in principle the algorithm converges to the minimum of $\chi^2$.

The LOCO jacobian matrix $\mathbf{J}$ dimension is $\mathrm{N}_{\mathrm{data}} \times \mathrm{N}_{\mathrm{knobs}}$. The number of data points $\mathrm{N}_{\mathrm{data}}$ is much greater than the typical number of knobs $\mathrm{N}_{\mathrm{knobs}}$ used as parameters. Hence, $\mathbf{J}$ is a rectangular matrix with much more rows than columns and the problem is highly over-constrained. For Sirius $\mathrm{N}_{\mathrm{data}} = 89920$ and $\mathrm{N}_{\mathrm{data}} \approx 1000$ for regular LOCO fittings. Moreover, since $\mathbf{J}$ is not a square matrix, $\mathbf{J}^{-1}$ is actually a pseudo-inverse, obtained by \gls{svd} pseudo-inversion.

To summarize, the \gls{gn} method seeks for the minimum of $\chi^2$ by iteratively applying the parameters variations, calculated by

\begin{equation}
    \Delta \vec{P} = - \mathbf{J}^{-1} \vec{V}.
\end{equation}

Since $\mathbf{J}$ is a huge matrix, its \gls{svd} decomposition to perform the pseudo-inversion may be very time consuming and storing the matrices may demand a lot of computer memory. So a strategy to 
circumvent this technical problem is to rewrite the problem as $\mathbf{J}^{\mathsf{T}}\Delta \vec{V} = \mathbf{J}^{\mathsf{T}}\mathbf{J}\Delta \vec{P}$. In that way, the parameters variations are calculated by

\begin{equation}
    \Delta \vec{P} = - \left(\mathbf{J}^{\mathsf{T}} \mathbf{J}\right)^{-1}\mathbf{J}^{\mathsf{T}} \vec{V}.
\end{equation}

The matrix $\mathbf{J}^{\mathsf{T}} \mathbf{J}$ has a smaller dimension $\mathrm{N}_{\mathrm{knobs}} \times \mathrm{N}_{\mathrm{knobs}}$ so the aforementioned computational 
inconveniences are greatly reduced.

\subsection{Levenberg-Marquardt Algorithm}
\section{Functionalities}
\subsection{Finding errors}
\subsection{Optics correction}
\subsection{Coupling correction}

\section{Degeneracies}

\section{Constraints and weights}

